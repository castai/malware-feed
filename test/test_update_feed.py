import bz2
import gzip
import io
import lzma

import pytest
import src.update_feed as src


class TestVersionParsing:
    def test_regular_semantic_version(self):
        vers = src.normalize_version("1.2.3")
        assert vers == src.SemVer(1, 2, 3)

    def test_major_minor_semantic_version(self):
        vers = src.normalize_version("1.2")
        assert vers == src.SemVer(1, 2, 0)

    def test_only_major_semantic_version(self):
        vers = src.normalize_version("1")
        assert vers == src.SemVer(1, 0, 0)

    def test_semantic_version_with_v_prefix(self):
        vers = src.normalize_version("v1.2.3")
        assert vers == src.SemVer(1, 2, 3)

    def test_only_major_semantic_version_with_v_prefix(self):
        vers = src.normalize_version("v1")
        assert vers == src.SemVer(1, 0, 0)

    def test_semantic_version_with_label(self):
        lbl = "alpha"
        vers = src.normalize_version(f"1.2.3-{lbl}")
        assert vers == src.SemVer(1, 2, 3, label=lbl)

    def test_malformed_label_without_dash(self):
        lbl = "alpha"
        vers = src.normalize_version(f"1.2.3{lbl}")
        assert vers == src.SemVer(1, 2, 3, label=lbl)

    def test_version_with_prefix_and_label(self):
        lbl = "alpha"
        vers = src.normalize_version(f"vers10.20.30{lbl}")
        assert vers == src.SemVer(10, 20, 30, label=lbl)


class TestVersionIsPrintedAsString:
    def test_regular_semantic_version(self):
        lbl = "alpha"
        vers = src.SemVer(1, 2, 3, label=lbl)
        assert str(vers) == f"1.2.3-{lbl}"


class TestAssetProcessorDetermination:
    def test_regular_tar_gz(self):
        name = "archive.tar.gz"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert is_archive
        assert processor_fn == src.process_tarball

    def test_old_tz_archive(self):
        name = "archive.tgz"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert is_archive
        assert processor_fn == src.process_tarball

    def test_tar_bz2(self):
        name = "archive.tar.bz2"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert is_archive
        assert processor_fn == src.process_tarball

    def test_tar_xz(self):
        name = "archive.tar.xz"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert processor_fn == src.process_tarball
        assert is_archive

    def test_metadata_for_tarball_is_ignored(self):
        name = "archive_v1.27.0_darwin_all.tar.gz.cid"
        data = b"just some ASCII text"
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert not is_archive
        assert processor_fn is None

    def test_bzip2_file(self):
        name = "archive.bz2"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert not is_archive
        assert processor_fn == src.process_bzip2_file

    def test_gzip_file(self):
        name = "archive.gz"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert not is_archive
        assert processor_fn == src.process_gzip_file

    def test_xz_file(self):
        name = "archive.xz"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert not is_archive
        assert processor_fn == src.process_xz_file

    def test_raw_binary_file(self):
        name = "binary.bin"
        data = b"\x7fELFarstarst"
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        # this is just an anonymous function returning the data itself
        res = processor_fn(name, data)
        assert not is_archive
        assert res == [(name, data)]
        # assert processor_fn == src.process_binary

    # def test_7zip(self):
    #     name = "archive.7z"
    #     data = b""
    #     is_archive, processor_fn = src.determine_asset_processor(name, data)
    #     assert is_archive
    #     assert processor_fn == src.process_7zip

    def test_unknown_extension(self):
        name = "archive.xyz"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert not is_archive
        assert processor_fn is None


class TestAssetProcessing:
    @pytest.mark.parametrize(
        "compressor, suffix, processor_fn",
        [
            (bz2, "bz2", src.process_bzip2_file),
            (gzip, "gz", src.process_gzip_file),
            (lzma, "xz", src.process_xz_file),
        ],
    )
    def test_compressed_files(self, compressor, suffix, processor_fn):
        expected_name = "my-file"
        file = io.BytesIO()
        data = b"file content"
        with compressor.open(file, "wb") as f:
            f.write(data)
        file.seek(0)  # point to the beginning of the file

        proc_fn = processor_fn(f"{expected_name}.{suffix}", file.read())
        name, content = next(proc_fn)
        assert name == expected_name
        assert content == data


class TestAssetVariantExtraction:
    def test_variant_after_tag(self):
        variant = "darwin-arm64"
        tag = "1.2.3"
        repo_name = "malware"
        release = {"tag_name": tag}
        asset = {"name": f"{repo_name}-{tag}-{variant}.tar.gz"}
        extracted = src.extract_asset_variant(repo_name, release, asset)
        assert extracted == variant

    def test_variant_between_name_and_tag(self):
        variant = "darwin-arm64"
        tag = "1.2.3"
        repo_name = "malware"
        release = {"tag_name": tag}
        asset = {"name": f"{repo_name}-{variant}-{tag}.tar.gz"}
        extracted = src.extract_asset_variant(repo_name, release, asset)
        assert extracted == variant

    def test_no_variant(self):
        variant = ""
        tag = "1.2.3"
        repo_name = "malware"
        release = {"tag_name": tag}
        asset = {"name": f"{repo_name}-{tag}.tar.gz"}
        extracted = src.extract_asset_variant(repo_name, release, asset)
        assert extracted == variant

    def test_variant_in_dot_notation(self):
        variant = "variant"
        tag = "1.2.3"
        repo_name = "malware"
        release = {"tag_name": tag}
        asset = {"name": f"{repo_name}-{tag}.{variant}.tar.gz"}
        extracted = src.extract_asset_variant(repo_name, release, asset)
        assert extracted == variant

    def test_no_tag_in_asset_name(self):
        variant = "variant"
        tag = ""
        repo_name = "malware"
        release = {"tag_name": tag}
        asset = {"name": f"{repo_name}-{variant}.tar.gz"}
        extracted = src.extract_asset_variant(repo_name, release, asset)
        assert extracted == variant


class TestDeduplicateFeedEntries:
    def test_no_duplicates(self):
        malwares = []
        res = src.deduplicate_entries(malwares=malwares, repos=[])
        # no changes were made
        assert malwares == res

    def test_duplicates_keep_first_entry(self):
        malware = src.Malware(
            name="malware-first",
            category="miner",
            hashes={"123": (src.SemVer(0, 0, 0), "")},
        )
        malwares = [
            malware,  # the one with more info is added later
            src.Malware(
                name="malware-second",
                category="hacking",
                hashes={"123": (src.SemVer(1, 2, 3), "darwin-arm64")},
            ),
        ]

        res = src.deduplicate_entries(malwares=malwares, repos=[])
        assert len(res) == 2  # both entries are still in there
        assert res[0] == malware
        assert len(res[1].hashes) == 0  # hash was removed from 2nd entry
