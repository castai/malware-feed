import bz2
from functools import partial
import gzip
import io
import lzma
import tarfile
import zipfile

import pytest
import src.update_feed as src


class TestParseGithubReleaseLinkHeader:
    def test_no_link_header_returns_null(self):
        assert src._parse_link_header({}) is None

    def test_only_next_and_last_in_heaer(self):
        base_url = "https://api.github.com/repositories/123/releases"
        next = base_url + "?page=2"
        last = base_url + "?page=7"
        links = f'<{next}>; rel="next", <{last}>; rel="last"'

        links = {
            "first": None,
            "prev": None,
            "next": base_url + "?page=4",
            "last": base_url + "?page=5",
        }

        link_entries = ", ".join(
            f"<{url}>; rel={name}" for name, url in links.items() if url is not None
        )
        pages = src._parse_link_header({"Link": link_entries})
        assert pages is not None
        assert pages == links

    def test_all_entries(self):
        base_url = "https://api.github.com/repositories/123/releases"
        links = {
            "first": base_url + "?page=1",
            "prev": base_url + "?page=2",
            "next": base_url + "?page=4",
            "last": base_url + "?page=5",
        }

        link_entries = ", ".join(f"<{url}>; rel={name}" for name, url in links.items())
        pages = src._parse_link_header({"Link": link_entries})
        assert pages is not None
        assert pages == links


class TestVersionParsing:
    def test_regular_semantic_version(self):
        vers = src.normalize_version("1.2.3")
        assert vers == src.SemVer(1, 2, 3)

    def test_major_minor_semantic_version(self):
        vers = src.normalize_version("1.2")
        assert vers == src.SemVer(1, 2, 0)

    def test_only_major_semantic_version(self):
        vers = src.normalize_version("1")
        assert vers == src.SemVer(1, 0, 0)

    def test_semantic_version_with_v_prefix(self):
        vers = src.normalize_version("v1.2.3")
        assert vers == src.SemVer(1, 2, 3)

    def test_only_major_semantic_version_with_v_prefix(self):
        vers = src.normalize_version("v1")
        assert vers == src.SemVer(1, 0, 0)

    def test_semantic_version_with_label(self):
        lbl = "alpha"
        vers = src.normalize_version(f"1.2.3-{lbl}")
        assert vers == src.SemVer(1, 2, 3, label=lbl)

    def test_malformed_label_without_dash(self):
        lbl = "alpha"
        vers = src.normalize_version(f"1.2.3{lbl}")
        assert vers == src.SemVer(1, 2, 3, label=lbl)

    def test_version_with_prefix_and_label(self):
        lbl = "alpha"
        vers = src.normalize_version(f"vers10.20.30{lbl}")
        assert vers == src.SemVer(10, 20, 30, label=lbl)


class TestFilterRelevantAssetsByName:
    @pytest.mark.parametrize(
        "os_indicator",
        [
            "darwin",
            "macos",
            "freebsd",
            "netbsd",
            "openbsd",
            "dragonfly",
            "android",
            "plan9",
            "solaris",
        ],
    )
    def test_filter_irrelevant_os(self, os_indicator):
        asset = f"malware-1.2.3-{os_indicator}-arm64.tar.gz"
        assert not src.is_asset_relevant(asset)

    @pytest.mark.parametrize("indicator", ["SHA256SUMS", "SHA256SUMS.sig", "checksum"])
    def test_filter_release_hash_files(self, indicator):
        assert not src.is_asset_relevant(indicator)

    def test_when_unclear_accept_asset(self):
        asset = "malware-1.2.3.tar.gz"
        assert src.is_asset_relevant(asset)

    @pytest.mark.parametrize("os", ["linux", "ubuntu", "debian", "focal", "bionic"])
    def test_accept_linux(self, os):
        asset = f"malware-1.2.3-{os}.tar.gz"
        assert src.is_asset_relevant(asset)


class TestVersionIsPrintedAsString:
    def test_regular_semantic_version(self):
        lbl = "alpha"
        vers = src.SemVer(1, 2, 3, label=lbl)
        assert str(vers) == f"1.2.3-{lbl}"


class TestAssetProcessorDetermination:
    def test_regular_tar_gz(self):
        name = "archive.tar.gz"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert is_archive
        assert processor_fn == src.process_tarball

    def test_old_tz_archive(self):
        name = "archive.tgz"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert is_archive
        assert processor_fn == src.process_tarball

    def test_tar_bz2(self):
        name = "archive.tar.bz2"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert is_archive
        assert processor_fn == src.process_tarball

    def test_tar_xz(self):
        name = "archive.tar.xz"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert processor_fn == src.process_tarball
        assert is_archive

    def test_metadata_for_tarball_is_ignored(self):
        name = "archive_v1.27.0_darwin_all.tar.gz.cid"
        data = b"just some ASCII text"
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert not is_archive
        assert processor_fn is None

    def test_bzip2_file(self):
        name = "archive.bz2"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert not is_archive
        assert processor_fn == src.process_bzip2_file

    def test_gzip_file(self):
        name = "archive.gz"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert not is_archive
        assert processor_fn == src.process_gzip_file

    def test_xz_file(self):
        name = "archive.xz"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert not is_archive
        assert processor_fn == src.process_xz_file

    def test_raw_binary_file(self):
        name = "binary.bin"
        data = b"\x7fELFarstarst"
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        # this is just an anonymous function returning the data itself
        res = processor_fn(name, data)
        assert not is_archive
        assert res == [(name, data)]
        # assert processor_fn == src.process_binary

    def test_python_script(self):
        name = "script.py"
        data = b"print('Hello World!')"
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        # this is just an anonymous function returning the data itself
        res = processor_fn(name, data)
        assert not is_archive
        assert res == [(name, data)]
        # assert processor_fn == src.process_binary

    # def test_7zip(self):
    #     name = "archive.7z"
    #     data = b""
    #     is_archive, processor_fn = src.determine_asset_processor(name, data)
    #     assert is_archive
    #     assert processor_fn == src.process_7zip

    def test_unknown_extension(self):
        name = "archive.xyz"
        data = b""
        is_archive, processor_fn = src.determine_asset_processor(name, data)
        assert not is_archive
        assert processor_fn is None


class TestFileProcessing:
    @pytest.mark.parametrize(
        "compressor, suffix, processor_fn",
        [
            (bz2, "bz2", src.process_bzip2_file),
            (gzip, "gz", src.process_gzip_file),
            (lzma, "xz", src.process_xz_file),
        ],
    )
    def test_compressed_files(self, compressor, suffix, processor_fn):
        expected_name = "my-file"
        file = io.BytesIO()
        data = b"file content"
        with compressor.open(file, "wb") as f:
            f.write(data)
        file.seek(0)  # point to the beginning of the file

        proc_fn = processor_fn(f"{expected_name}.{suffix}", file.read())
        name, content = next(proc_fn)
        assert name == expected_name
        assert content == data


class TestAssetVariantExtraction:
    def test_variant_after_tag(self):
        variant = "darwin-arm64"
        tag = "1.2.3"
        repo_name = "malware"
        release = {"tag_name": tag}
        asset = src.Asset(f"{repo_name}-{tag}-{variant}.tar.gz", "")
        extracted = src.extract_asset_variant(repo_name, release, asset)
        assert extracted == variant

    def test_variant_between_name_and_tag(self):
        variant = "darwin-arm64"
        tag = "1.2.3"
        repo_name = "malware"
        release = {"tag_name": tag}
        asset = src.Asset(f"{repo_name}-{variant}-{tag}.tar.gz", "")
        extracted = src.extract_asset_variant(repo_name, release, asset)
        assert extracted == variant

    def test_no_variant(self):
        variant = ""
        tag = "1.2.3"
        repo_name = "malware"
        release = {"tag_name": tag}
        asset = src.Asset(f"{repo_name}-{tag}.tar.gz", "")
        extracted = src.extract_asset_variant(repo_name, release, asset)
        assert extracted == variant

    def test_variant_in_dot_notation(self):
        variant = "variant"
        tag = "1.2.3"
        repo_name = "malware"
        release = {"tag_name": tag}
        asset = src.Asset(f"{repo_name}-{tag}.{variant}.tar.gz", "")
        extracted = src.extract_asset_variant(repo_name, release, asset)
        assert extracted == variant

    def test_no_tag_in_asset_name(self):
        variant = "variant"
        tag = ""
        repo_name = "malware"
        release = {"tag_name": tag}
        asset = src.Asset(f"{repo_name}-{variant}.tar.gz", "")
        extracted = src.extract_asset_variant(repo_name, release, asset)
        assert extracted == variant


class TestDeduplicateFeedEntries:
    def test_no_duplicates(self):
        malwares = []
        res = src.deduplicate_entries(malwares=malwares, repos=[])
        # no changes were made
        assert malwares == res

    def test_duplicates_keep_first_entry(self):
        malware = src.Malware(
            name="malware-first",
            category="miner",
            hashes={"123": (src.SemVer(0, 0, 0), "")},
        )
        malwares = [
            malware,  # the one with more info is added later
            src.Malware(
                name="malware-second",
                category="hacking",
                hashes={"123": (src.SemVer(1, 2, 3), "darwin-arm64")},
            ),
        ]

        res = src.deduplicate_entries(malwares=malwares, repos=[])
        assert len(res) == 2  # both entries are still in there
        assert res[0] == malware
        assert len(res[1].hashes) == 0  # hash was removed from 2nd entry


class MockAssetResponse:
    # mock json() method always returns a specific testing dictionary
    @staticmethod
    def read():
        return {"mock_key": "mock_response"}


def _mock_download(name: str, content: bytes, url: str, *args, **kwargs):
    if ".tar" in url:
        ext = url.rsplit(".", maxsplit=1)[-1]
        mode = "" if ext == "tar" else ":" + ext
        fh = io.BytesIO()
        with tarfile.open(fileobj=fh, mode=f"w{mode}") as tar:
            info = tarfile.TarInfo(name)
            info.size = len(content)
            tar.addfile(info, io.BytesIO(initial_bytes=content))
        return fh.getvalue()
    elif url.endswith(".zip"):
        fh = io.BytesIO()
        with zipfile.ZipFile(fh, mode="w", compression=zipfile.ZIP_DEFLATED) as zf:
            zf.writestr(name, content)
        return fh.getvalue()
    elif url.endswith(".bz2"):
        return bz2.compress(content)
    elif url.endswith(".gz"):
        return gzip.compress(content)
    elif url.endswith(".xz"):
        return lzma.compress(content)
    else:  # raw file
        return content


class TestAssetProcessing:
    @pytest.mark.parametrize(
        "filetype", [".tar.gz", ".tar", ".zip", ".bz2", ".gz", ".xz", None]
    )
    @pytest.mark.parametrize("variant", ["linux", "focal", "ubuntu", None])
    def test_keep_linux_elf_files(self, monkeypatch, variant, filetype):
        content = src.Magic.ELF.value + b"file content"
        malware = "malware"
        tag = "1.2.3"
        asset_name = "-".join([p for p in [malware, tag, variant] if p is not None])

        # create the mocked download
        monkeypatch.setattr(
            src, "_download_asset", partial(_mock_download, asset_name, content)
        )

        file_name = asset_name
        if filetype is not None:
            file_name += filetype
        file, res_hash = src.get_uncompressed_asset_name_and_hash(
            malware,
            file_name,
            f"https://github.com/user/repo/releases/download/{tag}/{file_name}",
        )
        assert file == asset_name
        assert res_hash is not None

    @pytest.mark.parametrize("filetype", [".tar.gz", ".zip", ".gz", ".xz", None])
    @pytest.mark.parametrize("variant", ["darwin-arm64", "macos", "osx", "mac64", None])
    def test_skip_mac_files(self, monkeypatch, variant, filetype):
        content = src.Magic.MACHO_64.value + b"file content"
        malware = "malware"
        tag = "1.2.3"
        asset_name = "-".join([p for p in [malware, tag, variant] if p is not None])

        # create the mocked download
        monkeypatch.setattr(
            src, "_download_asset", partial(_mock_download, asset_name, content)
        )
        file_name = asset_name
        if filetype is not None:
            file_name += filetype
        _, res_hash = src.get_uncompressed_asset_name_and_hash(
            malware,
            file_name,
            f"https://github.com/user/repo/releases/download/{tag}/{file_name}",
        )
        assert res_hash is None
