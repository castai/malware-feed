package repo

import (
	"context"
	"fmt"
	"log/slog"
	"os"

	"github.com/castai/malware-feed/internal/config"
	"github.com/castai/malware-feed/internal/domain"
	"github.com/google/go-github/v63/github"
)

type GithubRepo struct {
	Url         string
	Category    string
	MalwareName string
	RepoName    string
	Owner       string
}

// func (r GithubRepo) fetchReleases(out chan<- Release) {

// 	defer close(out)
// }

var GH_TOKEN = os.Getenv("GH_TOKEN")

func convertRelease(release github.RepositoryRelease) Release {
	tagName := release.GetTagName()
	version := domain.ParseVersion(tagName)
	tagAsVariant := version == domain.SemVer{} // tag is not a valid SemVer
	return Release{
		Name:        release.GetName(),
		Url:         release.GetURL(),
		Version:     version,
		ReleaseDate: release.GetCreatedAt().Time,
		Tag:         tagName,
		// AssetEntries: release.Assets,
		TagAsVariant: tagAsVariant,
	}
	// tag_name = release.get("tag_name", "")
	// version = normalize_version(tag_name)
	// tag_as_variant = False  # flag to explicitely use tag in the feeds variant field
	// date = datetime.datetime.fromisoformat(release.get("published_at", ""))
	// # if no proper version can be inferred, use the release date as version
	// if version == SemVer():
	// 	version = SemVer(
	// 		date.year,
	// 		date.month,
	// 		date.day,
	// 		label=f"{date.hour:02}:{date.minute:02}",
	// 	)
	// 	tag_as_variant = True

	// return Release(
	// 	name=release.get("name", ""),
	// 	url=release.get("url", ""),
	// 	version=version,
	// 	date=date,
	// 	tag=tag_name,
	// 	asset_entries=release.get("assets", []),
	// 	tag_as_variant=tag_as_variant,
	// )
}

func (r GithubRepo) GetReleases(crawlArgs config.CrawlArgs, out chan Release) {
	// const results_per_page = 100
	// url := fmt.Sprintf("https://api.github.com/repos/%s/%s/releases?per_page=%d", r.Owner, r.RepoName, results_per_page)

	client := github.NewClient(nil)
	opts := &github.ListOptions{PerPage: 100}
	releases, _, err := client.Repositories.ListReleases(context.Background(), r.Owner, r.RepoName, opts)
	if err != nil {
		slog.Error(fmt.Sprintf("Failed to fetch releases: %s", err))
	}

	for _, release := range releases {
		fmt.Printf(release.CreatedAt.Time.String())
		out <- convertRelease(*release)
	}

	// ghClient := http.Client{
	// 	Timeout: time.Second * 2, // Timeout after 2 seconds
	// }
	// req, err := http.NewRequest(http.MethodGet, url, nil)
	// if err != nil {
	// 	slog.Error("Failed to make request")
	// }

	// res, err := ghClient.Do(req)
	// if err != nil {
	// 	log.Fatal(err)
	// }

	// if res.StatusCode != 200 {
	// 	slog.Error("[%d] Failed to fetch releases from %s: %s", res.StatusCode, r.Url, res.Status)
	// }

	// if res.Body != nil {
	// 	defer res.Body.Close()
	// }

	// body, err := io.ReadAll(res.Body)
	// if err != nil {
	// 	log.Fatal(err)
	// }
	// result := make(map[string]interface{})
	// json.Unmarshal(body, &result)

	// releaseChannel := make(chan Release)
	// r.fetchReleases(releaseChannel)

	// for release := range releaseChannel {
	// out <- release
	// TODO check if crawl termination criterioin is met

	// }
	close(out)
}

func (r GithubRepo) GetForks(crawlArgs config.CrawlArgs, out chan<- Repo) {
}

func (r GithubRepo) GetUrl() string {
	return r.Url
}
